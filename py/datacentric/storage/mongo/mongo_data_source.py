# Copyright (C) 2013-present The DataCentric Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import attr
from abc import ABC
from bson import ObjectId
from typing import Union
import stringcase
from pymongo import MongoClient
from pymongo.database import Database
from datacentric.storage.mongo.mongo_server_key import MongoServerKey
from datacentric.storage.context import Context
from datacentric.storage.data_source import DataSource
from datacentric.storage.env_type import EnvType


@attr.s(slots=True, auto_attribs=True)
class MongoDataSource(DataSource, ABC):
    """
    Abstract base class for data source implementations based on MongoDB.

    This class provides functionality shared by all MongoDB data source types.
    """

    mongo_server: str = attr.ib(default=None, kw_only=True, metadata={'optional': True})
    """
    Specifies Mongo server for this data source.

    Defaults to local server on the standard port if not specified.

    Server URI specified here must refer to the entire server, not
    an individual database.
    """

    # --- CLASS VARIABLES

    __prohibited_symbols = '/\\. "$*<>:|?'
    __max_db_name_length = 64

    # --- INSTANCE VARIABLES

    __db_name: str = attr.ib(default=None, init=False)
    """Name of the database"""

    __db: Database = attr.ib(default=None, init=False)
    """PyMongo database object."""

    __client: MongoClient = attr.ib(default=None, init=False)
    """PyMongo database client."""

    __prev_object_id: ObjectId = attr.ib(default=DataSource._empty_id, init=False)
    """
    Previous ObjectId generated by this instance of the data source.
    
    This variable is used to ensure generation of ObjectIds in 
    strictly increasing order.
    """

    def init(self, context: Context) -> None:
        """
        Set Context property and perform validation of the record's data,
        then initialize any fields or properties that depend on that data.

        This method may be called multiple times for the same instance,
        possibly with a different context parameter for each subsequent call.

        IMPORTANT - Every override of this method must call base.Init()
        first, and only then execute the rest of the override method's code.
        """

        # Initialize base before executing the rest of the code in this method
        super().init(context)

        if self.env_type in [EnvType.Prod, EnvType.Uat, EnvType.Dev, EnvType.User, EnvType.Test]:

            # For all env types except Custom, database name consists of env type in uppercase,
            # and env group, env name converted from snake_case to PascalCase, with all three
            # then concatenated with semicolon delimiter
            env_type_pascal_case: str = stringcase.constcase(self.env_type.name)
            env_group_pascal_case: str = stringcase.pascalcase(self.env_group)
            env_name_pascal_case: str = stringcase.pascalcase(self.env_name)
            self.__db_name: str = ';'.join([env_type_pascal_case, env_group_pascal_case, env_name_pascal_case])

        elif self.env_type == EnvType.Custom:

            # For Custom env type, env group must be empty and env name
            # is database name
            if self.env_group is not None and self.env_group != '':
                raise Exception(f'Data source has env_group={self.env_group}, however it'
                                f'must be empty for env_type=Custom.')
            self.__db_name = self.env_name

        elif self.env_type == EnvType.Empty:
            raise Exception('Data source has empty env_type.')
        else:
            raise Exception(f'Data source has unknown value of env_type={self.env_type.name}.')

        # Check that database name length does not exceed Mongo limit
        # to prevent an obscure message from PyMongo about namespace
        # being not valid
        db_name_length_in_bytes: int = len(self.__db_name.encode('utf-8'))
        if db_name_length_in_bytes > MongoDataSource.__max_db_name_length:
            raise Exception(f'Database name {self.__db_name} has {db_name_length_in_bytes} bytes '
                            f'which exceeds MongoDB limit of {MongoDataSource.__max_db_name_length} bytes. '
                            f'Note that the number of bytes may exceed the number of characters for '
                            f'Unicode strings.')

        # Check for prohibited symbols
        if any(x in self.__db_name for x in MongoDataSource.__prohibited_symbols):
            raise Exception(f'MongoDB database name {self.__db_name} contains a space or another '
                            f'prohibited character from the following list: /\\.\"$*<>:|?')

        # Create PyMongo client and database objects
        self.__client = MongoClient(self.mongo_server)
        self.__db = self.__client.get_database(self.__db_name)

    @property
    def db(self) -> Database:
        """Interface to Mongo database in PyMongo driver."""
        return self.__db

    def create_ordered_object_id(self) -> ObjectId:
        result = ObjectId()

        retry_count = 0
        while result <= self.__prev_object_id:
            retry_count = retry_count + 1
            if retry_count == 0:
                self.context.log.warning('MongoDB generated ObjectId not in increasing order, retrying.')
                result = ObjectId()

        if retry_count != 0:
            self.context.log.warning(f'Generated ObjectId in increasing order after {retry_count} retries.')

        self.__prev_object_id = result
        return result

    def delete_db(self) -> None:
        """Permanently deletes (drops) the database with all records
        in it without the possibility to recover them later.

        This method should only be used to free storage. For
        all other purposes, methods that preserve history should
        be used.

        ATTENTION - THIS METHOD WILL DELETE ALL DATA WITHOUT
        THE POSSIBILITY OF RECOVERY. USE WITH CAUTION.
        """

        if self.read_only is not None and self.read_only:
            raise Exception(f'Attempting to drop (delete) database for the data source {self.data_source_name} '
                            f'where ReadOnly flag is set.')

        if self.__client is not None and self.__db is not None:
            
            if self.env_type in [EnvType.Dev, EnvType.User, EnvType.Test]:
                # Only env types Dev, User, and Test of can be deleted from the API
                self.__client.drop_database(self.__db)
            else:
                # Other env types must be deleted using an external tool
                raise Exception(f'As an extra safety measure, database {self.__db_name} cannot be '
                                f'dropped because this operation is not permitted for '
                                f'env_type={self.env_type.name}.')
